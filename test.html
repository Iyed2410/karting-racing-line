<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karting Optimizer - Automated Tests</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            color: #ff6600;
            margin-bottom: 20px;
            border-bottom: 2px solid #ff6600;
            padding-bottom: 10px;
        }

        .summary {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .stat {
            background: #2d2d2d;
            padding: 15px 25px;
            border-radius: 8px;
            border-left: 4px solid #ff6600;
        }

        .stat-label {
            font-size: 0.9rem;
            color: #999;
            text-transform: uppercase;
        }

        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin-top: 5px;
        }

        .stat-value.pass {
            color: #00cc66;
        }

        .stat-value.fail {
            color: #ff3333;
        }

        .stat-value.total {
            color: #ff6600;
        }

        .tests {
            display: grid;
            gap: 2px;
        }

        .test-group {
            background: #2d2d2d;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .group-header {
            background: #404040;
            padding: 12px 16px;
            font-weight: bold;
            color: #ff6600;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .group-stats {
            font-size: 0.85rem;
            color: #999;
        }

        .test-item {
            padding: 12px 16px;
            border-bottom: 1px solid #1a1a1a;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .test-item:last-child {
            border-bottom: none;
        }

        .test-item.pass {
            background: rgba(0, 204, 102, 0.05);
            border-left: 3px solid #00cc66;
        }

        .test-item.fail {
            background: rgba(255, 51, 51, 0.05);
            border-left: 3px solid #ff3333;
        }

        .test-icon {
            font-size: 1.2rem;
            font-weight: bold;
            min-width: 20px;
        }

        .test-icon.pass {
            color: #00cc66;
        }

        .test-icon.fail {
            color: #ff3333;
        }

        .test-name {
            flex: 1;
            font-size: 0.95rem;
        }

        .test-error {
            color: #ff9999;
            font-size: 0.85rem;
            margin-left: 32px;
            padding: 8px;
            background: rgba(255, 51, 51, 0.1);
            border-radius: 4px;
            word-break: break-word;
        }

        .test-duration {
            color: #999;
            font-size: 0.85rem;
            min-width: 60px;
            text-align: right;
        }

        .button {
            background: #ff6600;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: bold;
            margin-top: 20px;
            transition: all 0.3s;
        }

        .button:hover {
            background: #ff9933;
            transform: translateY(-2px);
        }

        .button:active {
            transform: translateY(0);
        }

        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #404040;
            color: #666;
            font-size: 0.9rem;
            text-align: center;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-size: 1.2rem;
            color: #ff6600;
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
            margin-left: 8px;
        }

        @keyframes dots {

            0%,
            20% {
                content: '';
            }

            40% {
                content: '.';
            }

            60% {
                content: '..';
            }

            80%,
            100% {
                content: '...';
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ðŸ§ª Karting Optimizer - Test Suite</h1>

        <div id="loading" class="loading">Running tests</div>
        <div id="results" style="display: none;"></div>

        <button class="button" onclick="location.reload()">Run Tests Again</button>

        <div class="footer">
            <p>Karting Racing Line Optimizer v1.0 | Test Suite</p>
            <p>All modules loaded successfully. Tests running in browser console.</p>
        </div>
    </div>

    <!-- Load all utility modules -->
    <script src="utils/geometry.js"></script>
    <script src="utils/physics.js"></script>
    <script src="utils/racingLine.js"></script>
    <script src="utils/uiHelpers.js"></script>

    <script>
        // Test framework
        class TestRunner {
            constructor() {
                this.groups = {};
                this.results = [];
            }

            group(name) {
                this.currentGroup = name;
                this.groups[name] = [];
                return this;
            }

            test(name, fn) {
                const startTime = performance.now();
                const result = {
                    name,
                    group: this.currentGroup,
                    pass: false,
                    error: null,
                    duration: 0
                };

                try {
                    fn();
                    result.pass = true;
                    result.duration = performance.now() - startTime;
                } catch (e) {
                    result.error = e.message;
                    result.duration = performance.now() - startTime;
                }

                this.results.push(result);
                if (!this.groups[this.currentGroup]) {
                    this.groups[this.currentGroup] = [];
                }
                this.groups[this.currentGroup].push(result);

                console.log(`${result.pass ? 'âœ“' : 'âœ—'} ${name}${result.error ? ': ' + result.error : ''}`);
            }

            assert(condition, message) {
                if (!condition) throw new Error(message);
            }

            render() {
                const html = this.generateHTML();
                document.getElementById('results').innerHTML = html;
                document.getElementById('results').style.display = 'block';
                document.getElementById('loading').style.display = 'none';
            }

            generateHTML() {
                const passed = this.results.filter(r => r.pass).length;
                const failed = this.results.filter(r => !r.pass).length;
                const total = this.results.length;
                const passRate = total > 0 ? ((passed / total) * 100).toFixed(1) : 0;

                let html = `
          <div class="summary">
            <div class="stat">
              <div class="stat-label">Passed</div>
              <div class="stat-value pass">${passed}</div>
            </div>
            <div class="stat">
              <div class="stat-label">Failed</div>
              <div class="stat-value fail">${failed}</div>
            </div>
            <div class="stat">
              <div class="stat-label">Total</div>
              <div class="stat-value total">${total}</div>
            </div>
            <div class="stat">
              <div class="stat-label">Pass Rate</div>
              <div class="stat-value ${passRate === 100 ? 'pass' : passRate === 0 ? 'fail' : ''}">${passRate}%</div>
            </div>
          </div>
          
          <div class="tests">
        `;

                // Group results by test group
                for (const groupName in this.groups) {
                    const groupTests = this.groups[groupName];
                    const groupPassed = groupTests.filter(t => t.pass).length;
                    const groupTotal = groupTests.length;

                    html += `
            <div class="test-group">
              <div class="group-header">
                <span>${groupName}</span>
                <span class="group-stats">${groupPassed}/${groupTotal} passed</span>
              </div>
          `;

                    for (const test of groupTests) {
                        html += `
              <div class="test-item ${test.pass ? 'pass' : 'fail'}">
                <div class="test-icon ${test.pass ? 'pass' : 'fail'}">
                  ${test.pass ? 'âœ“' : 'âœ—'}
                </div>
                <div class="test-name">${test.name}</div>
                <div class="test-duration">${test.duration.toFixed(2)}ms</div>
              </div>
            `;

                        if (test.error) {
                            html += `<div class="test-error">${test.error}</div>`;
                        }
                    }

                    html += `</div>`;
                }

                html += `</div>`;
                return html;
            }
        }

        // Create test runner
        const runner = new TestRunner();

        // ====== GEOMETRY TESTS ======
        runner.group('Geometry - Basic');

        runner.test('distance: 3-4-5 triangle', () => {
            const d = distance({ x: 0, y: 0 }, { x: 3, y: 4 });
            runner.assert(Math.abs(d - 5) < 0.01, `Expected 5, got ${d}`);
        });

        runner.test('distance: zero distance', () => {
            const d = distance({ x: 5, y: 5 }, { x: 5, y: 5 });
            runner.assert(Math.abs(d) < 0.01, 'Same point should be 0');
        });

        runner.test('heading: right direction', () => {
            const h = heading({ x: 0, y: 0 }, { x: 1, y: 0 });
            runner.assert(Math.abs(h) < 0.01, 'Should be ~0 radians');
        });

        runner.test('angle: 90 degree corner', () => {
            const a = angle({ x: 0, y: 1 }, { x: 0, y: 0 }, { x: 1, y: 0 });
            runner.assert(Math.abs(a - Math.PI / 2) < 0.01, 'Should be ~90Â°');
        });

        runner.group('Geometry - Curvature');

        runner.test('curvature: straight line', () => {
            const c = curvature({ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0 });
            runner.assert(Math.abs(c) < 0.01, 'Straight should be ~0');
        });

        runner.test('radiusOfCurvature: works', () => {
            const r = radiusOfCurvature({ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 2, y: 0 });
            runner.assert(r === Infinity, 'Straight line should have infinite radius');
        });

        runner.test('trackLength: sums distances', () => {
            const points = [{ x: 0, y: 0 }, { x: 3, y: 4 }, { x: 6, y: 8 }];
            const len = trackLength(points);
            runner.assert(Math.abs(len - 10) < 0.01, 'Should be 5+5=10');
        });

        runner.group('Geometry - Interpolation');

        runner.test('interpolate: creates more points', () => {
            const points = [{ x: 0, y: 0 }, { x: 100, y: 0 }];
            const interp = interpolate(points, 5);
            runner.assert(interp.length > points.length, 'Should create more points');
        });

        runner.test('interpolate: preserves endpoints', () => {
            const points = [{ x: 0, y: 0 }, { x: 100, y: 0 }, { x: 100, y: 100 }];
            const interp = interpolate(points, 5);
            runner.assert(interp.length > 0, 'Should return points');
        });

        runner.group('Geometry - Validation');

        runner.test('trackSelfIntersects: detects crossing', () => {
            const points = [
                { x: 0, y: 0 }, { x: 10, y: 10 },
                { x: 10, y: 0 }, { x: 0, y: 10 }
            ];
            const crosses = trackSelfIntersects(points);
            runner.assert(crosses, 'Should detect intersection');
        });

        runner.test('trackSelfIntersects: passes clean track', () => {
            const points = [
                { x: 0, y: 0 }, { x: 100, y: 0 },
                { x: 100, y: 100 }, { x: 0, y: 100 }
            ];
            const crosses = trackSelfIntersects(points);
            runner.assert(!crosses, 'Clean track should pass');
        });

        // ====== PHYSICS TESTS ======
        runner.group('Physics - Speed');

        runner.test('maxCornerSpeed: calculates correctly', () => {
            // v = sqrt(1.0 * 9.81 * 10) â‰ˆ 9.9 m/s
            const v = kart.maxCornerSpeed(10);
            runner.assert(Math.abs(v - 9.9) < 0.5, `Expected ~9.9, got ${v}`);
        });

        runner.test('maxCornerSpeed: larger radius = faster', () => {
            const v1 = kart.maxCornerSpeed(5);
            const v2 = kart.maxCornerSpeed(20);
            runner.assert(v2 > v1, 'Larger radius should be faster');
        });

        runner.test('maxCornerSpeed: respects grip', () => {
            const orig = kart.gripCoefficient;
            kart.gripCoefficient = 0.5;
            const v1 = kart.maxCornerSpeed(10);
            kart.gripCoefficient = 1.0;
            const v2 = kart.maxCornerSpeed(10);
            runner.assert(v2 > v1, 'Higher grip = higher speed');
            kart.gripCoefficient = orig;
        });

        runner.group('Physics - Braking');

        runner.test('brakingDistance: positive result', () => {
            const d = kart.brakingDistance(20, 10);
            runner.assert(d >= 0, 'Should be positive');
        });

        runner.test('brakingDistance: stopping longer than partial', () => {
            const d1 = kart.brakingDistance(20, 0);
            const d2 = kart.brakingDistance(20, 10);
            runner.assert(d2 < d1, 'Partial brake should be shorter');
        });

        runner.group('Physics - Profile');

        runner.test('computeSpeedProfile: returns array', () => {
            const segments = [
                { length: 10, speed: 15 },
                { length: 10, speed: 10 }
            ];
            const profile = kart.computeSpeedProfile(segments);
            runner.assert(profile.length === segments.length, 'Wrong length');
        });

        runner.test('canMaintainSpeed: works', () => {
            const maxSpeed = kart.maxCornerSpeed(10);
            const canSlow = kart.canMaintainSpeed(maxSpeed * 0.5, 10);
            const canFast = kart.canMaintainSpeed(maxSpeed * 2, 10);
            runner.assert(canSlow && !canFast, 'Speed check failed');
        });

        // ====== RACING LINE TESTS ======
        runner.group('Racing Line - Generation');

        runner.test('initialHeuristicLine: returns array', () => {
            const center = [{ x: 0, y: 0 }, { x: 10, y: 0 }, { x: 20, y: 10 }];
            const line = initialHeuristicLine(center);
            runner.assert(Array.isArray(line) && line.length > 0, 'Should return array');
        });

        runner.test('smoothLine: preserves point count', () => {
            const points = [
                { x: 0, y: 0 }, { x: 10, y: 20 }, { x: 20, y: 0 }
            ];
            const smoothed = smoothLine(points, 3);
            runner.assert(smoothed.length === points.length, 'Should preserve count');
        });

        runner.test('findApexes: returns indices', () => {
            const line = [
                { x: 0, y: 0 }, { x: 10, y: 5 }, { x: 20, y: 0 }
            ];
            const apexes = findApexes(line);
            runner.assert(Array.isArray(apexes), 'Should return array');
        });

        runner.group('Racing Line - Validation');

        runner.test('validateRacingLine: accepts valid line', () => {
            const line = [{ x: 0, y: 0 }, { x: 10, y: 10 }, { x: 20, y: 0 }];
            const trackData = { boundaries: null };
            const result = validateRacingLine(line, trackData);
            runner.assert(result.valid, 'Should be valid');
        });

        runner.test('validateRacingLine: rejects short line', () => {
            const line = [{ x: 0, y: 0 }];
            const trackData = { boundaries: null };
            const result = validateRacingLine(line, trackData);
            runner.assert(!result.valid, 'Should be invalid');
        });

        // ====== CANVAS TESTS ======
        runner.group('Canvas - Initialization');

        runner.test('CanvasManager: creates successfully', () => {
            const canvas = document.createElement('canvas');
            const manager = new CanvasManager(canvas);
            runner.assert(manager.trackPoints !== undefined, 'Should initialize');
        });

        runner.test('CanvasManager: has history', () => {
            const canvas = document.createElement('canvas');
            const manager = new CanvasManager(canvas);
            runner.assert(manager.history.length >= 0, 'Should have history');
        });

        runner.group('Canvas - Operations');

        runner.test('addTrackPoint: adds point', () => {
            const canvas = document.createElement('canvas');
            const manager = new CanvasManager(canvas);
            manager.addTrackPoint(10, 20);
            runner.assert(manager.trackPoints.length > 0, 'Should add point');
        });

        runner.test('clearTrack: removes all points', () => {
            const canvas = document.createElement('canvas');
            const manager = new CanvasManager(canvas);
            manager.addTrackPoint(10, 20);
            manager.clearTrack();
            runner.assert(manager.trackPoints.length === 0, 'Should clear');
        });

        runner.test('undo/redo: works', () => {
            const canvas = document.createElement('canvas');
            const manager = new CanvasManager(canvas);
            manager.addTrackPoint(10, 20);
            const len1 = manager.trackPoints.length;
            manager.undo();
            const len2 = manager.trackPoints.length;
            runner.assert(len1 > len2, 'Undo should remove');
        });

        // ====== INTEGRATION TESTS ======
        runner.group('Integration - Full Pipeline');

        runner.test('optimize simple track', () => {
            const track = [
                { x: 0, y: 0 }, { x: 100, y: 0 }, { x: 100, y: 100 }, { x: 0, y: 100 }
            ];

            const trackData = { segments: [], boundaries: null };
            for (let i = 0; i < track.length - 1; i++) {
                trackData.segments.push({
                    length: distance(track[i], track[i + 1]),
                    speed: 15,
                    radius: 50
                });
            }

            const initial = initialHeuristicLine(track);
            const optimized = optimizeLine(initial, trackData, 3);
            const smooth = smoothLine(optimized, 1);

            runner.assert(smooth.length > 0, 'Should produce line');
        });

        runner.test('calculateLapTime: works', () => {
            const line = [
                { x: 0, y: 0 }, { x: 100, y: 0 }, { x: 100, y: 100 }
            ];
            const trackData = { segments: [] };
            const time = calculateLapTime(line, trackData);
            runner.assert(typeof time === 'number', 'Should return number');
        });

        // ====== PERFORMANCE TESTS ======
        runner.group('Performance - Speed');

        runner.test('interpolate: fast', () => {
            const points = [];
            for (let i = 0; i < 100; i++) {
                points.push({ x: Math.random() * 1000, y: Math.random() * 1000 });
            }
            const start = performance.now();
            interpolate(points, 3);
            const elapsed = performance.now() - start;
            runner.assert(elapsed < 100, `Took ${elapsed.toFixed(2)}ms (should be <100ms)`);
        });

        runner.test('initial heuristic: fast', () => {
            const track = [];
            for (let i = 0; i < 50; i++) {
                track.push({
                    x: 100 + 100 * Math.cos(i * Math.PI * 2 / 50),
                    y: 100 + 100 * Math.sin(i * Math.PI * 2 / 50)
                });
            }
            const start = performance.now();
            initialHeuristicLine(track);
            const elapsed = performance.now() - start;
            runner.assert(elapsed < 100, `Took ${elapsed.toFixed(2)}ms`);
        });

        // Render results
        setTimeout(() => {
            runner.render();
            console.log(`\nâœ… Test suite complete: ${runner.results.filter(r => r.pass).length}/${runner.results.length} passed`);
        }, 100);
    </script>
</body>

</html>